<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/eslint.config.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/eslint.config.ts" />
              <option name="originalContent" value="import globals from &quot;globals&quot;;&#10;import tseslint from &quot;typescript-eslint&quot;;&#10;&#10;export default [&#10;    {&#10;        files: [&quot;**/*.{js,mjs,cjs,ts,mts,cts}&quot;],&#10;        languageOptions: {&#10;            globals: globals.node,&#10;            parser: tseslint.parser,&#10;            parserOptions: {&#10;                ecmaVersion: 2022,&#10;                sourceType: &quot;module&quot;,&#10;                project: &quot;./tsconfig.json&quot;,&#10;                tsconfigRootDir: import.meta.dirname,&#10;            },&#10;        },&#10;        plugins: {&#10;            &quot;@typescript-eslint&quot;: tseslint.plugin,&#10;        },&#10;        rules: {&#10;            ...tseslint.configs.recommended.rules,&#10;            &quot;@typescript-eslint/no-unused-vars&quot;: &quot;error&quot;,&#10;            &quot;@typescript-eslint/no-explicit-any&quot;: &quot;warn&quot;,&#10;            &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;off&quot;,&#10;            &quot;@typescript-eslint/explicit-module-boundary-types&quot;: &quot;off&quot;,&#10;            &quot;@typescript-eslint/no-inferrable-types&quot;: &quot;off&quot;,&#10;            &quot;prefer-const&quot;: &quot;error&quot;,&#10;            &quot;no-var&quot;: &quot;error&quot;,&#10;        },&#10;    },&#10;    {&#10;        files: [&quot;tests/**/*.ts&quot;],&#10;        rules: {&#10;            &quot;@typescript-eslint/no-explicit-any&quot;: &quot;off&quot;,&#10;        },&#10;    },&#10;];&#10;" />
              <option name="updatedContent" value="import globals from &quot;globals&quot;;&#10;import tseslint from &quot;typescript-eslint&quot;;&#10;&#10;export default [&#10;    {&#10;        files: [&quot;**/*.{js,mjs,cjs,ts,mts,cts}&quot;],&#10;        languageOptions: {&#10;            globals: globals.node,&#10;            parser: tseslint.parser,&#10;            parserOptions: {&#10;                ecmaVersion: 2022,&#10;                sourceType: &quot;module&quot;,&#10;                project: &quot;./tsconfig.json&quot;,&#10;                tsconfigRootDir: import.meta.dirname,&#10;            },&#10;        },&#10;        plugins: {&#10;            &quot;@typescript-eslint&quot;: tseslint.plugin,&#10;        },&#10;        rules: {&#10;            ...tseslint.configs.recommended.rules,&#10;            &quot;@typescript-eslint/no-unused-vars&quot;: &quot;error&quot;,&#10;            &quot;@typescript-eslint/no-explicit-any&quot;: &quot;warn&quot;,&#10;            &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;off&quot;,&#10;            &quot;@typescript-eslint/explicit-module-boundary-types&quot;: &quot;off&quot;,&#10;            &quot;@typescript-eslint/no-inferrable-types&quot;: &quot;off&quot;,&#10;            &quot;prefer-const&quot;: &quot;error&quot;,&#10;            &quot;no-var&quot;: &quot;error&quot;,&#10;        },&#10;    },&#10;    {&#10;        files: [&quot;tests/**/*.ts&quot;],&#10;        rules: {&#10;            &quot;@typescript-eslint/no-explicit-any&quot;: &quot;off&quot;,&#10;        },&#10;    },&#10;];" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/infrastructure/server.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/infrastructure/server.ts" />
              <option name="originalContent" value="import 'reflect-metadata';&#10;import express from 'express';&#10;import http from 'http';&#10;import {Server, Socket} from 'socket.io';&#10;import mongoose from 'mongoose';&#10;import bodyParser from 'body-parser';&#10;import {JWT_SECRET} from '../config/env';&#10;import jwt from 'jsonwebtoken';&#10;import authRouter from '../api/routes/auth';&#10;import roomsRouter from '../api/routes/rooms';&#10;import messagesRouter from '../api/routes/messages';&#10;import usersRouter from '../api/routes/users';&#10;import {setIo} from './io';&#10;import {Message} from &quot;../models/message.ts&quot;;&#10;import {Container} from &quot;typedi&quot;;&#10;import {UserService} from &quot;../services/userService.ts&quot;;&#10;&#10;export interface BuiltServer {&#10;    app: express.Express;&#10;    httpServer: http.Server;&#10;    io: Server;&#10;    close: () =&gt; Promise&lt;void&gt;;&#10;}&#10;&#10;interface AuthenticatedSocket extends Socket {&#10;    userId?: string;&#10;}&#10;&#10;const userService = () =&gt; Container.get(UserService);&#10;&#10;export async function buildServer(mongoUri: string): Promise&lt;BuiltServer&gt; {&#10;    if (mongoose.connection.readyState === 0) {&#10;        await mongoose.connect(mongoUri);&#10;    }&#10;    const app = express();&#10;    app.use(bodyParser.json());&#10;&#10;    app.use('/api/auth', authRouter);&#10;    app.use('/api/rooms', roomsRouter);&#10;    app.use('/api/rooms', messagesRouter);&#10;    app.use('/api/users', usersRouter);&#10;&#10;    const httpServer = http.createServer(app);&#10;    const io = new Server(httpServer, {cors: {origin: '*'}});&#10;    setIo(io);&#10;&#10;    io.use((socket: AuthenticatedSocket, next) =&gt; {&#10;        const token = socket.handshake.query?.token as string | undefined;&#10;        if (token) {&#10;            try {&#10;                const payload = jwt.verify(token, JWT_SECRET) as { id: string };&#10;                socket.userId = payload.id;&#10;            } catch {&#10;            }&#10;        }&#10;        next();&#10;    });&#10;&#10;    io.on('connection', async (socket: AuthenticatedSocket) =&gt; {&#10;        const userId = socket.userId;&#10;        if (userId) {&#10;            try {&#10;                await userService().setIsOnline(userId, true)&#10;            } catch (e) {&#10;                console.error('Failed to set user online status:', e);&#10;            }&#10;            socket.broadcast.emit('userOnline', {userId});&#10;        }&#10;        socket.on('joinRoom', (roomId: string, ack?: Function) =&gt; {&#10;            socket.join(roomId);&#10;            ack &amp;&amp; ack({ok: true});&#10;        });&#10;        socket.on('leaveRoom', (roomId: string, ack?: Function) =&gt; {&#10;            socket.leave(roomId);&#10;            ack &amp;&amp; ack({ok: true});&#10;        });&#10;        socket.on('chatMessage', async (data: { roomId: string; content: string }, ack?: Function) =&gt; {&#10;            try {&#10;                if (!userId) throw new Error('unauthenticated');&#10;                const message = await Message.create(&#10;                    {user: userId, room: data.roomId, content: data.content}&#10;                );&#10;                const payload = {&#10;                    _id: message._id.toString(),&#10;                    user: userId,&#10;                    room: data.roomId,&#10;                    content: data.content,&#10;                    timestamp: message.timestamp&#10;                };&#10;                io.to(data.roomId).emit('chatMessage', payload);&#10;                ack &amp;&amp; ack({ok: true, message: payload});&#10;            } catch (e: unknown) {&#10;                const error = e as Error || new Error('unknown error');&#10;                ack &amp;&amp; ack({ok: false, error: error.message});&#10;            }&#10;        });&#10;        socket.on('typing', (data: { roomId: string }, ack?: Function) =&gt; {&#10;            if (userId) io.to(data.roomId).emit('typing', {userId, roomId: data.roomId});&#10;            ack &amp;&amp; ack({ok: true});&#10;        });&#10;        socket.on('disconnect', async () =&gt; {&#10;            if (userId) {&#10;                try {&#10;                    // Only try to update the database if the connection is still active&#10;                    if (mongoose.connection.readyState === 1) {&#10;                        await userService().setIsOnline(userId, false)&#10;                    }&#10;                } catch (e) {&#10;                    console.error('Failed to set user offline status:', e);&#10;                }&#10;                socket.broadcast.emit('userOffline', {userId})&#10;            }&#10;        });&#10;    });&#10;&#10;    return {&#10;        app, httpServer, io, close: async () =&gt; {&#10;            await io.close();&#10;            await new Promise(r =&gt; httpServer.close(r));&#10;            if (mongoose.connection.readyState !== 0) await mongoose.disconnect();&#10;        }&#10;    };&#10;}&#10;" />
              <option name="updatedContent" value="import 'reflect-metadata';&#10;import express from 'express';&#10;import http from 'http';&#10;import {Server, Socket} from 'socket.io';&#10;import mongoose from 'mongoose';&#10;import bodyParser from 'body-parser';&#10;import {JWT_SECRET} from '../config/env';&#10;import jwt from 'jsonwebtoken';&#10;import authRouter from '../api/routes/auth';&#10;import roomsRouter from '../api/routes/rooms';&#10;import messagesRouter from '../api/routes/messages';&#10;import usersRouter from '../api/routes/users';&#10;import {setIo} from './io';&#10;import {Message} from &quot;../models/message.ts&quot;;&#10;import {Container} from &quot;typedi&quot;;&#10;import {UserService} from &quot;../services/userService.ts&quot;;&#10;&#10;export interface BuiltServer {&#10;    app: express.Express;&#10;    httpServer: http.Server;&#10;    io: Server;&#10;    close: () =&gt; Promise&lt;void&gt;;&#10;}&#10;&#10;interface AuthenticatedSocket extends Socket {&#10;    userId?: string;&#10;}&#10;&#10;const userService = () =&gt; Container.get(UserService);&#10;&#10;export async function buildServer(mongoUri: string): Promise&lt;BuiltServer&gt; {&#10;    if (mongoose.connection.readyState === 0) {&#10;        await mongoose.connect(mongoUri);&#10;    }&#10;    const app = express();&#10;    app.use(bodyParser.json());&#10;&#10;    app.use('/api/auth', authRouter);&#10;    app.use('/api/rooms', roomsRouter);&#10;    app.use('/api/rooms', messagesRouter);&#10;    app.use('/api/users', usersRouter);&#10;&#10;    const httpServer = http.createServer(app);&#10;    const io = new Server(httpServer, {cors: {origin: '*'}});&#10;    setIo(io);&#10;&#10;    io.use((socket: AuthenticatedSocket, next) =&gt; {&#10;        const token = socket.handshake.query?.token as string | undefined;&#10;        if (token) {&#10;            try {&#10;                const payload = jwt.verify(token, JWT_SECRET) as { id: string };&#10;                socket.userId = payload.id;&#10;            } catch {&#10;            }&#10;        }&#10;        next();&#10;    });&#10;&#10;    io.on('connection', async (socket: AuthenticatedSocket) =&gt; {&#10;        const userId = socket.userId;&#10;        if (userId) {&#10;            try {&#10;                await userService().setIsOnline(userId, true)&#10;            } catch (e) {&#10;                console.error('Failed to set user online status:', e);&#10;            }&#10;            socket.broadcast.emit('userOnline', {userId});&#10;        }&#10;        socket.on('joinRoom', (roomId: string, ack?: Function) =&gt; {&#10;            socket.join(roomId);&#10;            ack &amp;&amp; ack({ok: true});&#10;        });&#10;        socket.on('leaveRoom', (roomId: string, ack?: Function) =&gt; {&#10;            socket.leave(roomId);&#10;            ack &amp;&amp; ack({ok: true});&#10;        });&#10;        socket.on('chatMessage', async (data: { roomId: string; content: string }, ack?: Function) =&gt; {&#10;            try {&#10;                if (!userId) throw new Error('unauthenticated');&#10;                const message = await Message.create(&#10;                    {user: userId, room: data.roomId, content: data.content}&#10;                );&#10;                const payload = {&#10;                    _id: message._id.toString(),&#10;                    user: userId,&#10;                    room: data.roomId,&#10;                    content: data.content,&#10;                    timestamp: message.timestamp&#10;                };&#10;                io.to(data.roomId).emit('chatMessage', payload);&#10;                ack &amp;&amp; ack({ok: true, message: payload});&#10;            } catch (e: unknown) {&#10;                const error = e as Error || new Error('unknown error');&#10;                ack &amp;&amp; ack({ok: false, error: error.message});&#10;            }&#10;        });&#10;        socket.on('typing', (data: { roomId: string }, ack?: Function) =&gt; {&#10;            if (userId) io.to(data.roomId).emit('typing', {userId, roomId: data.roomId});&#10;            ack &amp;&amp; ack({ok: true});&#10;        });&#10;        socket.on('disconnect', async () =&gt; {&#10;            if (userId) {&#10;                try {&#10;                    // Only try to update the database if the connection is still active&#10;                    if (mongoose.connection.readyState === 1) {&#10;                        await userService().setIsOnline(userId, false)&#10;                    }&#10;                } catch (e) {&#10;                    console.error('Failed to set user offline status:', e);&#10;                }&#10;                socket.broadcast.emit('userOffline', {userId})&#10;            }&#10;        });&#10;    });&#10;&#10;    return {&#10;        app, httpServer, io, close: async () =&gt; {&#10;            await io.close();&#10;            await new Promise(r =&gt; httpServer.close(r));&#10;            if (mongoose.connection.readyState !== 0) await mongoose.disconnect();&#10;        }&#10;    };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>